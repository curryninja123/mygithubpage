<html>
    <head>
        <title>Home - Vishnu Iyer</title>
        <!--Import Google Icon Font-->
        <link href="http://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
        <!--Import materialize.css-->
        <link type="text/css" rel="stylesheet" href="css/materialize.min.css"  media="screen,projection"/>
        <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous">
        <!-- Import Cabin Font -->
        <link href="https://fonts.googleapis.com/css?family=Cabin" rel="stylesheet">
        <!-- Import Bootstrap -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
        <!--Let browser know website is optimized for mobile-->
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <link href="new.css" type = "text/css" rel="stylesheet">
    </head>
    <body>
        <div class="pure-g">
            <div class="pure-u-1-5"></div>
            <div class="pure-u-3-5">
                <h2 class="page-head">Morals</h2>
                <p class="body">
                    Here is a collection of morals and tips/tricks our section has come up with. This is intended to be a review of section as well as a homework helper and study resource for exams!
                </p>
                
                <h4 class="sub-head">6/18 Section 1A - Quantifiers and Logic</h4>
                <ul>
                    <li>DeMorgan's Extended Law - When negating quantified propositions, existential quantifiers flip to universal quantifiers and vise versa</li>
                    <li>Quantifier order matters!</li>
                    <li>Convert statements to easy English wherever possible.</li>
                    <li>Uniqueness implies that <b>for any</b> two solutions, they are equal.</li>
                </ul>
                <br>
                <h4 class="sub-head">6/19 Section 1B - Proof Techniques</h4>
                <ul>
                    <li>Parity (even vs odd) and order (less than, greater than) are good counter examples for proposition statements. In general, anything that divides a set into disjoint subsets that cover the whole set is a good test for a logical equivalence.</li>
                    <li>If you see "or" statements anywhere in an implication (especially on the right hand side), contraposition is probably a good idea.</li>
                    <li>If your proof seems on the right track but <i>very</i> handwavy or the proof seems difficult to do directly, try contradiction.</li>
                </ul>
                <br>
                <h4 class="sub-head">6/20 Section 1C - Induction</h4>
                <ul>
                    <li>For inductive proofs involving sums, it's usually a good idea to break off the last term.</li>
                    <li>When prooving the inductive step, try to separate the expression for the n=k case from the expression for the n=k+1 case algebraically.</li>
                    <li>If the inductive step depends on a term that is not the previous case (that is, something like n=k/2 or n=k-7 rather than n=k-1) then use strong induction.</li>
                </ul>
                <br>
                <h4 class="sub-head">6/21 Section 1D - Well Ordering Principle and Graphs</h4>
                <ul>
                    <li>Properties of trees are useful in proofs about cycles</li>
                    <li>Proofs involving the Well Ordering Principle usually follow from contradiction.</li>
                    <li>Whenever possible, try to prove statements about graphs directly using principles like the Handshake Lemma. These tend to be much more simple than inductive proofs. However, not all statements can be proved in this way.</li>
                </ul>
                <br>
                <h4 class="sub-head">6/25 Section 2A - Graph Theory</h4>
                <ul>
                    <li>The number of edges in a planar graph grow linearly with the number of vertices. That is, e = O(v).</li>
                    <li>For proofs about planarity, try to see if you can prove the statement directly with the 3v-6 edge upper bound before relying on techniques such as induction.</li>
                    <li>You can think of a dual of a planar graph as a shape whose corners are incident on all the faces of the original shape. For example, two rectangular pyramids with their bases touching is dual to a cube (imagine this shape inside a cube).</li>
                    <li>Duality has the interesting property that a dual of a dual of a graph is the same graph.</li>
                </ul>
                <br>
                <h4 class="sub-head">6/26 Section 2B - Graph Theory and Modular Arithmetic</h4>
                <ul>
                    <li>For proofs about coloring, induction might be worth a try. The idea is you ignore a vertex, inductive color the subgraph, add the vertex back, and pick a color for it.</li>
                    <li>Bipartite graphs can be defined as graphs that can be 2-colored (think of the left partition as one color and the right as another).</li>
                    <li>Systems of equations in mod work the same way as they do in the reals - you can add and subtract multiples of equations to each other.</li>
                    <li>The most general way to solve ax congruent to b mod m where a and m are relatively prime is to multiply both sides by the multiplicative inverse of a. This is the best way to get rid of an a on any side of a modular equation.</li>
                </ul>
                <br>
                <h4 class="sub-head">6/27 Section 2C - EGCD and Chinese Remainder Theorem</h4>
                <ul>
                    <li>There are multiple ways to perform the Extended Euclid GCD algorithm. The tabular way (see Piazza) is efficient, but in order to develop intuition, it's best to try the method on the discussion worksheet as well.</li>
                    <li>Intuitively, you can think of the GCD algorithm as folding a paper with integer lengths along a corner diagonal and then cutting out the resulting square until nothing is left - the last square is the GCD of the two numbers (see discussion 2C).</li>
                    <li>The Chinese Remainder Theorem interpolation problem can be thought of as constructing numbers which "raise" a particular modulo by 1 and keep the others at 0. If you are familiar with linear algebra, this is like creating basis vectors and then taking a linear combination of them to reconstruct the solution.</li>
                    <li>While CRT (and for that matter most modular arithmetic) problems tend to be hard to compuate but are straightforward to verify. Make sure you do this when going through an exam! </li>
                </ul>
                <br>
                <h4 class="sub-head">6/28 Section 2D - RSA</h4>
                <ul>
                    <li>In order to get rid of a term x on one side of a modular equation, multiply both sides by the inverse of x. Conversely, to get rid of the inverse of x, multiply both sides by x. Intuitively, this works the same way as it does in the real numbers.</li>
                    <li>Knowing the private keys in RSA is essentially equivalent to being able to factor the numbers.</li>
                    <li>The Chinese Remainder Theorem states that any system of k congruences of the form x is congruent to a<sub>i</sub> mod m<sub>i</sub> for relatively prime m<sub>i</sub> has a unique solution mod m<sub>1</sub>...m<sub>k</sub> (the product of the moduli). This is useful when solving for the value of a number od a product of primes - break it down into a smaller system of congruences and reconstruct the solution using the Chinese Remainder Theorem method shown earlier.</li>
                    <li>Most proofs for the RSA algorithm essentially follow the same format, but certain parts are different based on the variety in the scheme. For example, in the three-prime RSA scheme, we made the same argument as in the two-prime case, defining our value of N and private key modulo as natural extensions (see discussion 2d). It is worth understanding the purpose of each step and why we make it in order to extend this proof to different schemes.</li>
                </ul>
                <br>
                <h4 class="sub-head">7/2 Section 3A - Polynomials</h4>
                <ul>
                    <li>The Galois Field (GF) basically means you are considering the polynomial mod p for some prime p. As we will see later, it matters that p is prime for some important properties to hold. This means that the coefficients are reduced mod p. 7x will go to 2x mod 5.</li>
                    <li>A polynomial of degree d will have exactly d complex roots, some of which may be real. It makes sense intuitively that at most d roots will occur on the reals, because a nonzero polynomial of degree d may be equal to zero at at most d points (if it was equal at d+1 points it would just be the zero polynomial).</li>
                    <li>We know that imaginary roots will always be paired up, so there will be an even number of them.</li>
                    <li>Intuition about the number of roots is very different in GF(p) - make sure to think of counterexamples using FLT and similar theorems.</li>
                    <li>A polynomial of degree greater than or equal to p cannot exist in GF(p). This makes sense intuitively because there are at most p possible points that the polynomial can go through, and that specifies a polynomial of degree p-1. Mathematically, you can use FLT (try this out on your own) to reduce the degree of a polynomial in GF(p).</li>
                </ul>
                <br>
                <h4 class="sub-head">7/3 Section 3B - Error Correcting Codes</h4>
                <ul>
                    <li>Secret sharing and error correcting are two different motivations utilizing a similar concept - you can use some points to encode a polynomial and use that polynomial to generate more similar information. In the former case, you split up that information whereas in the latter case you send extra information to make up for lost or corrupted information.</li>
                    <li>For erased information, you add an extra amount of information equal to the number of packets lost. The intuition is harder for corrupted packets - you have to go through the derivation of the Berlekamp-Welch algorithm</li>
                    <li>r<sub>i</sub> is the <i>receieved</i> information not the <i>sent</i> information</li>.
                    <li>The key observation in Berlekamp-Welch is that Q(i) = P(i)E(i) = r<sub>i</sub> E(i)in the case where there is an error (because both sides are 0) and in the case where there isn't an error (because the received message r<sub>i</sub> is the same as the sent message P(i)</li>
                </ul>
                <br>
                <a class="bodylink" href="teaching.html">Back to teaching home page.</a>
            </div>
            <div class="pure-u-1-5"></div>
        </div>
        <br><br>
    </body>
</html>